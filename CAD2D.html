<!doctype html>
<html>
<head>
    <title>MyCAD 2D</title>
    <meta charset="utf-8" />
    <style>
        #content {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }

        #canvas, #preview {
            position: fixed;
            left: 0;
            top: 0;
            margin: 0;
            padding: 0;
            cursor: none;
        }

        #tool {
            position: fixed;
            right: 20px;
            top: 20px;
        }

        #cmd {
            position: fixed;
            bottom: 10px;
            height: 14px;
            padding: 2px 10px;
            border-radius: 3px;
            background-color: rgb(240,245,250);
            opacity: 0.8;
            line-height: 14px;
            font-family: Consolas;
            font-size: 12px;
            font-weight: 400;
            white-space: nowrap;
        }
    </style>
    <script id="global">
        var canvas, preview, Command;

        var Origin = [0, 0], Unit = 15;

        function fromCoordinate(P) {
            return [P[0] * Unit + Origin[0], -P[1] * Unit + Origin[1]];
        }
        function fromCanvas(P) {
            return [(P[0] - Origin[0]) / Unit, -(P[1] - Origin[1]) / Unit];
        }

        var Points = [[NaN, NaN], [0, 0]];
        var Objs = [];
        var Status = "select";
        var CursorType = "default";
        var CurrentEditing = -1;

        var PreviousWindowSize = [0, 0];
        function init() {
            canvas = document.getElementById("canvas"), preview = document.getElementById("preview");
            Command = document.getElementById("cmd");
            var w = window.innerWidth, h = window.innerHeight;
            PreviousWindowSize = [w, h];
            Origin = [w / 2, h / 2];
            Command.style.width = (0.6 * w) + "px", Command.style.left = (0.2 * w) + "px";
            Command.style.bottom = (0.0002 * h * h) + "px", Command.style.height = Command.style.lineHeight = (14 + 0.01 * h) + "px";
            Array.prototype.insert = function (item, index) {
                this.splice(index, 0, item);
            };
            Array.prototype.contains = function (obj) {
                var i = this.length;
                while (i--) {
                    if (this[i] === obj) return true;
                }
                return false;
            };
            window.onresize = function () {
                resizeCanvas();
            },
            window.onkeydown = function () {
                Onkeydown(event);
            },
            window.onkeyup = function () {
                Onkeyup(event);
            },
            window.onmousewheel = function () {
                mouseScroll(event);
            };
            resizeCanvas();
        }
        function resizeCanvas() {
            var w = Math.floor(window.innerWidth), h = Math.floor(window.innerHeight);
            var prevw = PreviousWindowSize[0], prevh = PreviousWindowSize[1];
            Unit *= Math.sqrt((w * h) / (prevw * prevh));
            Origin[0] *= w / prevw, Origin[1] *= h / prevh;
            PreviousWindowSize = [w, h];
            if ((canvas.width !== w) || (canvas.height !== h)) {
                canvas.width = preview.width = w;
                canvas.height = preview.height = h;
                canvas.style.width = preview.style.width = w + "px";
                canvas.style.height = preview.style.height = h + "px";
            }
            Command.style.width = (0.6 * w) + "px", Command.style.height = Command.style.lineHeight = (14 + 0.01 * h) + "px";
            Command.style.fontSize = (12 + 0.002 * h) + "px";
            Command.style.left = (0.2 * w) + "px", Command.style.bottom = (0.0002 * h * h) + "px";
            redraw();
        }

        var FitPoint = 0;  // 0: disable(default); -1: disable(manual); 1: on
        var FitPointTarget = -1;

        var EditHistory = [1];
        function logHistory(opr) {
            if (EditHistory[0] < EditHistory.length) {
                EditHistory.splice(EditHistory[0], EditHistory.length - EditHistory[0]);
            }
            EditHistory.push(opr);
            EditHistory[0]++;
        }
        function restoreHistory() {

        }

        var Commanding = false;

        var Debug = {
            copyArray : function copyArray(src) {
                if (typeof src != "object") return src;
                var r = [];
                for (var i = 0; i < src.length; i++) r.push(Debug.copyArray(src[i]));
                return r;
            },
            checkIllegal: function checkIllegal(src) {
                var isPositiveInt = function (n) {
                    if (typeof n != "number") return false;
                    if (Math.round(n) != n) return false;
                    return n > 0;
                },
                isWholeNumber = function (n) {
                    if (typeof n != "number") return false;
                    if (Math.round(n) != n) return false;
                    return n >= 0;
                };

                // basic checks
                if (Status == "select" && CurrentEditing != -1) {
                    throw "CurrentEditing equals to " + CurrentEditing + " in select mode";
                }
                if (FitPoint != 1 && FitPointTarget != -1) {
                    throw "FitPointTarget equals to " + FitPointTarget + " when FitPoint is off";
                }
                if (CurrentEditing != -1 && (!isWholeNumber(CurrentEditing) || CurrentEditing >= Objs.length)) {
                    throw "Invalid CurrentEditing " + CurrentEditing;
                }
                if (FitPointTarget != -1 && (!isPositiveInt(FitPointTarget) || FitPointTarget >= Points.length)) {
                    throw "Invalid FitPointTarget " + FitPointTarget;
                }

                // check points
                if (Points.length < 2) {
                    throw "Invalid Points length";
                }
                if (CurrentEditing == -1 && (!isNaN(Points[0][0]) || !isNaN(Points[0][1]))) {
                    throw "Points[0] not equal to NaN when CurrentEditing is equal to -1";
                }
                if (Points[1][0]!=0 || Points[1][1]!=0) {
                    throw "Points[1] not equal to [0,0]";
                }
                for (var i = 2; i < Points.length; i++) {
                    if (typeof Points[i] != "object" || Points[i].length != 2) {
                        throw "Invalid point [" + i + "]";
                    }
                    if (isNaN(Points[i][0]) || isNaN(Points[i][1])) {
                        throw "Points[" + i + "] equals to NaN";
                    }
                }

                // check objects
                for (var i = 0; i < Objs.length; i++) {
                    var s = "Objs[" + i + "] ";
                    if (Objs[i].length == 0) {
                        throw s + "Empty";
                    }
                    if (typeof Objs[i][0] != "string") {
                        throw s + "Signature Missing";
                    }
                    /*if (Objs[i].length == 1) {
                        throw s + "Parameter Missing";
                    }*/
                    switch (Objs[i][0]) {
                        case "segment": {
                            if (i != CurrentEditing && Objs[i].length != 3) {
                                throw s + "Invalid: Length " + Objs[i].length + "/3";
                            }
                            /*if (i == CurrentEditing && Objs[i].length != 2) {
                                throw s + "Invalid: Length " + Objs[i].length + "/2";
                            }*/
                            if (Objs[i].length == 3) {
                                if (!isPositiveInt(Objs[i][1]) || !isPositiveInt(Objs[i][1]) 
                                    || (Objs[i][1] >= Points.length || Objs[i][2] >= Points.length)) {
                                    throw s + "Parameter Invalid";
                                }
                                if (Objs[i][1] == Objs[i][2]) {
                                    throw s + "two endpoints of segment are equal";
                                }
                            }
                            break;
                        }
                        default: {
                            throw "Invalid Object Signature '" + Objs[i][0] + "'";
                        }
                    }
                }

                // check history
                if (EditHistory.length == 0) {
                    throw "Empty History";
                }
                if (!isPositiveInt(EditHistory[0]) || EditHistory[0] > EditHistory.length) {
                    throw "Invalid History Indicator";
                }
                for (var i = 1; i < EditHistory.length; i++) {
                    if (EditHistory[i].length == 0) {
                        throw s + "Empty";
                    }
                    if (typeof EditHistory[i][0] != "string") {
                        throw s + "Signature Missing";
                    }
                    if (EditHistory[i].length == 1) {
                        throw s + "Parameter Missing";
                    }
                    var s = "EditHistory[" + i + "] ";
                    switch (EditHistory[i][0]) {
                        case "begin line": {
                            // signature, dir of startpoint
                            if (EditHistory[i].length != 2) {
                                throw s + "Invalid: Length " + EditHistory[i].length + "/2";
                            }
                            if (!isPositiveInt(EditHistory[i][1]) || EditHistory[i][1] >= Points.length) {
                                throw s + "Parameter Invalid";
                            }
                            break;
                        }
                        case "new segment": {
                            break;
                        }
                        default: {
                            throw "Invalid History Signature '" + EditHistory[i][0] + "'";
                        }
                    }
                }
                for (var i = 1; i < EditHistory[0]; i++) {
                    var s = "EditHistory[" + i + "] ";
                    switch (EditHistory[i][0]) {
                        case "begin line": {
                            break;
                        }
                        case "new segment": {
                            // signature, dir of object
                            if (EditHistory[i].length != 2) {
                                throw s + "Invalid: Length " + EditHistory[i].length + "/3";
                            }
                            if (!isWholeNumber(EditHistory[i][1]) || EditHistory[i][1] >= Objs.length) {
                                throw s + "Parameter Invalid";
                            }
                            break;
                        }
                        default: {
                            throw "Invalid History Signature '" + EditHistory[i][0] + "'";
                        }
                    }
                }
                for (var i = EditHistory[0]; i < EditHistory.length; i++) {
                    var s = "EditHistory[" + i + "] ";
                    switch (EditHistory[i][0]) {
                        case "begin line": {
                            break;
                        }
                        case "new segment": {
                            // signature, backup of object
                            if (EditHistory[i].length != 2) {
                                throw s + "Invalid: Length " + EditHistory[i].length + "/2";
                            }
                            if (typeof EditHistory[i][1] != "object" || EditHistory[i][1].length != 3 || EditHistory[i][1][0] != "segment") {
                                throw s + "Invalid Backup";
                            }
                            if (!isPositiveInt(EditHistory[i][1][1]) || !isPositiveInt(EditHistory[i][1][2])
                                || (EditHistory[i][1][1] >= Points.length || EditHistory[i][1][2] >= Points.length)) {
                                throw s + "Backup Parameter Invalid";
                            }
                            if (EditHistory[i][1][1] == EditHistory[i][1][2]) {
                                throw s + "Backup: two endpoints of segment are equal";
                            }
                            break;
                        }
                        default: {
                            throw "Invalid History Signature '" + EditHistory[i][0] + "'";
                        }
                    }
                }

            },
            check: function check(condition, message) {
                if (!condition) throw message;
            }
        };
    </script>
</head>
<body onload="init()">
    <div id="content" oncontextmenu="event.preventDefault()">
        <canvas id="canvas"></canvas>
        <canvas id="preview" onmousemove="cursorMove(event)" onclick="mouseClick(event)" oncontextmenu="rightClick(event)"></canvas>
        <div id="tool"></div>
        <div id="cmd" title="command line" contenteditable spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"
             onfocus="Commanding=true;" onkeydown="if(event.keyCode==13)event.preventDefault(),runCommand();" onmouseover="preview.getContext('2d').clearRect(0, 0, preview.width, preview.height);"></div>
    </div>
    <script>

        function Objs_erase(dir) {
            Objs.splice(dir, 1);
            if (CurrentEditing > dir) CurrentEditing--;
            else if (CurrentEditing == dir) CurrentEditing = -1, Points[0] = [NaN, NaN];
        }
        function Objs_insert(dir, item) {
            Objs.splice(dir, 0, item);
            if (CurrentEditing >= dir) CurrentEditing++;
        }

        function redraw() {
            var w = canvas.width, h = canvas.height;
            var ctx = canvas.getContext("2d");

            // Background
            ctx.fillStyle = "rgb(16,20,23)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            var L = 100 / Unit;
            var tp = Math.pow(10, Math.floor(Math.log(L) / Math.LN10));
            L /= tp; L = (L < 2 ? 1 : L < 5 ? 2 : 5) * tp;
            var l = L / 5;
            var LeftTop = fromCanvas([0, 0]), RightBottom = fromCanvas([w, h]);
            LeftTop[0] = Math.round(LeftTop[0] / l - 0.5), LeftTop[1] = Math.round(LeftTop[1] / l + 0.5);
            RightBottom[0] = Math.round(RightBottom[0] / l + 0.5), RightBottom[1] = Math.round(RightBottom[1] / l - 0.5);

            // Minor gridlines
            ctx.strokeStyle = "rgb(55,65,75)";
            ctx.lineWidth = 0.2;
            ctx.setLineDash([]);
            ctx.beginPath();
            for (var i = LeftTop[0]; i <= RightBottom[0]; i++) {
                var P = fromCoordinate([i * l, 0]);
                ctx.moveTo(P[0], 0), ctx.lineTo(P[0], h);
            }
            for (var i = LeftTop[1]; i >= RightBottom[1]; i--) {
                var P = fromCoordinate([0, i * l]);
                ctx.moveTo(0, P[1]), ctx.lineTo(w, P[1]);
            }
            ctx.stroke();

            // Major gridlines
            LeftTop[0] = Math.round(LeftTop[0] / 5 - 0.5), LeftTop[1] = Math.round(LeftTop[1] / 5 + 0.5);
            RightBottom[0] = Math.round(RightBottom[0] / 5 + 0.5), RightBottom[1] = Math.round(RightBottom[1] / 5 - 0.5); ctx.strokeStyle = "rgb(55,65,75)";
            ctx.lineWidth = 0.4;
            ctx.beginPath();
            for (var i = LeftTop[0]; i <= RightBottom[0]; i++) {
                var P = fromCoordinate([i * L, 0]);
                ctx.moveTo(P[0], 0), ctx.lineTo(P[0], h);
            }
            for (var i = LeftTop[1]; i >= RightBottom[1]; i--) {
                var P = fromCoordinate([0, i * L]);
                ctx.moveTo(0, P[1]), ctx.lineTo(w, P[1]);
            }
            ctx.stroke();

            // Axis
            ctx.strokeStyle = "rgb(80,75,140)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(Origin[0], 0);
            ctx.lineTo(Origin[0], canvas.height);
            ctx.moveTo(0, Origin[1]);
            ctx.lineTo(canvas.width, Origin[1]);
            ctx.stroke();

            // Objects
            ctx.strokeStyle = "White";
            ctx.lineWidth = 1.2;
            for (var i = 0; i < Objs.length; i++) {
                if (Objs[i].length <= 1);
                else switch (Objs[i][0]) {
                    case "polyline": {
                        Line(ctx, i); break;
                    }
                    case "segment": {
                        Segment(ctx, i); break;
                    }
                }
            }

        }
        function repreview(mouseevent) {
            redraw();
            var ctx = preview.getContext("2d");
            ctx.clearRect(0, 0, preview.width, preview.height);
            drawCursor(mouseevent);
            if (FitPointTarget != -1) highlightPoint(Points[FitPointTarget]);
        }

        function drawCursor(event) {
            var x = event.clientX, y = event.clientY;
            var ctx = preview.getContext("2d");
            switch (CursorType) {
                case "default": {
                    ctx.strokeStyle = "Lime";
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(x - 12, y);
                    ctx.lineTo(x + 12, y);
                    ctx.moveTo(x, y - 12);
                    ctx.lineTo(x, y + 12);
                    ctx.stroke();
                    break;
                }
            }
        }
        function highlightPoint(P) {
            var ctx = preview.getContext("2d");
            ctx.strokeStyle = "Lime";
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            var Q = fromCoordinate(P);
            ctx.moveTo(Q[0] - 6, Q[1]);
            ctx.lineTo(Q[0] + 6, Q[1]);
            ctx.moveTo(Q[0], Q[1] - 6);
            ctx.lineTo(Q[0], Q[1] + 6);
            ctx.stroke();
        }



    </script>

    <script id="events">
        function FindFitPoint(P) {
            var dist = Infinity, dir = -1, dx, dy, d;
            for (var i = 1; i < Points.length; i++) {
                dx = P[0] - Points[i][0], dy = P[1] - Points[i][1];
                d = dx * dx + dy * dy;
                if (d < dist) dist = d, dir = i;
            }
            if (CurrentEditing != -1 && dir == Objs[CurrentEditing][Objs[CurrentEditing].length - 1]) return -1;
            if (Math.sqrt(dist) * Unit < 20) return dir;
            return -1;
        }

        function cursorMove(event) {
            var P = fromCanvas([event.clientX, event.clientY]);
            switch (Status) {
                case "select": {
                    repreview(event);
                    break;
                }
                case "segment": {
                    Points[0] = P;
                    if (FitPoint == 1) {
                        FitPointTarget = FindFitPoint(P);
                    }
                    repreview(event);
                    break;
                }
                case "circle": {
                    break;
                }
                case "arc": {
                    break;
                }
                case "spline": {
                    break;
                }
            }
        }

        function mouseClick(event) {
            Debug.checkIllegal();

            Commanding = false;
            if (FitPoint != -1) FitPoint = 1;

            var P = fromCanvas([event.clientX, event.clientY]);
            var ctx = canvas.getContext("2d");
            ctx.strokeStyle = "White";
            switch (Status) {
                case "select": {
                    break;
                }
                case "segment": {
                    if (FitPointTarget != -1) {
                        Objs[CurrentEditing].push(FitPointTarget);
                        FitPointTarget = -1;
                    }
                    else {
                        Points.push(P);
                        Objs[CurrentEditing].push(Points.length - 1);
                    }
                    if (Objs[CurrentEditing].length == 3) {
                        Objs_insert(CurrentEditing, ["segment", Objs[CurrentEditing][1], Objs[CurrentEditing][2]]);
                        CurrentEditing--;
                        logHistory(["new segment", CurrentEditing]);
                        CurrentEditing++;
                        Objs[CurrentEditing].splice(1, 1);
                    }
                    else {
                        logHistory(["begin line", Objs[CurrentEditing][1]]);
                    }
                    Debug.checkIllegal();
                    console.log("Add Point", "\nPoints: ", Debug.copyArray(Points), "\nObjs: ", Debug.copyArray(Objs), "\nCurrentEditing: ", CurrentEditing, "\nEditHistory: ", Debug.copyArray(EditHistory));
                    break;
                }
                case "circle": {
                    break;
                }
                case "arc": {
                    break;
                }
                case "spline": {
                    break;
                }
            }
        }

        var keyStack = [];
        function Onkeydown(event) {
            if (Commanding) return;
            if (event.keyCode != 116 && event.keyCode != 123) event.preventDefault();   // F5, F12
            else return;
            if (keyStack[keyStack.length - 1] == event.keyCode) return;
            keyStack.push(event.keyCode);
            switch (event.keyCode) {
                case 13: { // Enter
                    Points[0] = [NaN, NaN];
                    Status = "select";
                    if (Objs[CurrentEditing].length <= 2) Objs_erase(CurrentEditing);
                    CurrentEditing = -1, Points[0] = [NaN, NaN];
                    if (FitPoint != -1) FitPoint = 0;
                    FitPointTarget = -1;
                    cursorMove(event);
                    redraw(); break;
                }
                case 16: { // Shift
                    console.log("Shift");
                    break;
                }
                case 17: { // Ctrl
                    console.log("Ctrl");
                    break;
                }
                case 18: { // Alt
                    console.log("Alt");
                    break;
                }
                case 20: { // Caps Lock

                }
                case 33: { // PageUp
                    Origin[1] -= canvas.height * 0.3;
                    redraw(); return;
                }
                case 34: { // PageDown
                    Origin[1] += canvas.height * 0.3;
                    redraw(); return;
                }
                case 37: { // left
                    Origin[0] -= canvas.width * 0.1;
                    redraw(); return;
                }
                case 38: { // top
                    Origin[1] -= canvas.height * 0.1;
                    redraw(); return;
                }
                case 39: { // right
                    Origin[0] += canvas.width * 0.1;
                    redraw(); return;
                }
                case 40: { // bottom
                    Origin[1] += canvas.height * 0.1;
                    redraw(); return;
                }
                case 89: { // y
                    if (keyStack.length == 2 && keyStack[0] == 17) { // Ctrl+Y
                        Debug.checkIllegal();
                        var dir = EditHistory[0];
                        if (dir == EditHistory.length) return;
                        else switch (EditHistory[dir][0]) {
                            case "begin line": {
                                if (Status != "select") CurrentEditing = -1, Points[0] = [NaN, NaN], Status = "select";
                                if (FitPoint != -1) FitPoint = 0;
                                if (++dir != EditHistory.length && EditHistory[dir][0] == "new segment") EditHistory[0]++;  // directly do next step
                                else break;
                            }
                            case "new segment": {
                                if (CurrentEditing != -1) {
                                    Objs_insert(CurrentEditing, ["segment", EditHistory[dir][1][1], EditHistory[dir][1][2]]);
                                    Objs[CurrentEditing][1] = Objs[CurrentEditing - 1][2];
                                    EditHistory[dir][1] = CurrentEditing - 1;
                                    break;
                                }
                                Objs.push(["segment", EditHistory[dir][1][1], EditHistory[dir][1][2]]);
                                EditHistory[dir][1] = Objs.length - 1;
                                if (CurrentEditing != -1) CurrentEditing++;
                                break;
                            }
                        }
                        EditHistory[0]++;
                        console.log("Ctrl+Y", "\nPoints: ", Debug.copyArray(Points), "\nObjs: ", Debug.copyArray(Objs), "\nCurrentEditing: ", CurrentEditing, "\nEditHistory: ", Debug.copyArray(EditHistory));
                        Debug.checkIllegal();
                        redraw(); return;
                    }
                    break;
                }
                case 90: { // z
                    if (keyStack.length == 2 && keyStack[0] == 17) { // Ctrl+Z
                        Debug.checkIllegal();
                        if (EditHistory[0] == 1) {
                            if (Status == "segment") Objs_erase(CurrentEditing);
                            Status = "select";
                            CurrentEditing = -1, Points[0] = [NaN, NaN];
                            Debug.checkIllegal();
                            redraw(); return;
                        }
                        EditHistory[0]--;
                        var hist = EditHistory[EditHistory[0]];
                        switch (hist[0]) {
                            case "begin line": {
                                // signature, dir of startpoint
                                if (Status == "segment") {
                                    if (Objs[CurrentEditing].length <= 2) Objs_erase(CurrentEditing);
                                    Status = "select";
                                    CurrentEditing = -1, Points[0] = [NaN, NaN];
                                    if (FitPoint != -1) FitPoint = 0;
                                    break;
                                }
                                else if (EditHistory[EditHistory[0] - 1][0] == "new segment") {
                                    EditHistory[0]--;
                                    hist = EditHistory[EditHistory[0]];
                                }
                                else break;
                            }
                            case "new segment": {
                                // signature, dir of object
                                var del = hist[1];
                                hist[1] = ["segment", Objs[del][1], Objs[del][2]];
                                if (Status == "segment") {
                                    Objs[CurrentEditing][1] = hist[1][1];
                                }
                                Objs_erase(del);
                                break;
                            }
                        }
                        console.log("Ctrl+Z", "\nPoints: ", Debug.copyArray(Points), "\nObjs: ", Debug.copyArray(Objs), "\nCurrentEditing: ", CurrentEditing, "\nEditHistory: ", Debug.copyArray(EditHistory));
                        Debug.checkIllegal();
                        redraw(); return;
                    }
                    break;
                }
                case 114: { // F3
                    if (FitPoint == -1) FitPoint = (CurrentEditing == -1) ? 0 : 1;
                    else FitPoint = -1, FitPointTarget = -1;
                    console.log("F3");
                    return;
                }
                case 122: { // F11
                    document.getElementById("content").webkitRequestFullscreen();
                    return;
                }
                default: {
                    console.log("Keycode: ", event.keyCode);
                    break;
                }
            }
            if (event.keyCode >= 65 && event.keyCode <= 90) {
                Commanding = true;
                KeyStack = [];
                Command.innerText += String.fromCharCode(event.keyCode + 32);

                // Based on https://stackoverflow.com/questions/1125292/how-to-move-cursor-to-end-of-contenteditable-entity
                var setEndOfContenteditable = function (contentEditableElement) {
                    var voidNodeTags = ['AREA', 'BASE', 'BR', 'COL', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'MENUITEM', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR', 'BASEFONT', 'BGSOUND', 'FRAME', 'ISINDEX'];
                    var canContainText = function canContainText(node) {
                        if (node.nodeType == 1) return !voidNodeTags.contains(node.nodeName);
                        else return false;
                    };
                    var getLastChildElement = function getLastChildElement(el) {
                        var lc = el.lastChild;
                        while (lc && lc.nodeType != 1) {
                            if (lc.previousSibling) lc = lc.previousSibling;
                            else break;
                        }
                        return lc;
                    };
                    while (getLastChildElement(contentEditableElement) &&
                          canContainText(getLastChildElement(contentEditableElement))) {
                        contentEditableElement = getLastChildElement(contentEditableElement);
                    }
                    var range, selection;
                    if (document.createRange)//Firefox, Chrome, Opera, Safari, IE 9+
                    {
                        range = document.createRange();//Create a range (a range is a like the selection but invisible)
                        range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range
                        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
                        selection = window.getSelection();//get the selection object (allows you to change selection)
                        selection.removeAllRanges();//remove any selections already made
                        selection.addRange(range);//make the range you have just created the visible selection
                    }
                    else if (document.selection)//IE 8 and lower
                    {
                        range = document.body.createTextRange();//Create a range (a range is a like the selection but invisible)
                        range.moveToElementText(contentEditableElement);//Select the entire contents of the element with the range
                        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
                        range.select();//Select the range (make it the visible selection
                    }
                }

                Command.focus();
                setEndOfContenteditable(Command);
            }
        }
        function Onkeyup(event) {
            if (Commanding) {
                keyStack = []; return;
            }
            if (event.keyCode != 116 && event.keyCode != 123) event.preventDefault();
            else return;
            for (i = keyStack.length - 1; i >= 0; i--) {
                if (keyStack[i] == event.keyCode) {
                    keyStack.splice(i, 1);
                    //break;
                }
            }
        }

        function rightClick(event) {

        }

        function mouseScroll(event) {
            var d = Math.exp(0.0008 * event.wheelDelta);
            var x = event.clientX, y = event.clientY;
            Origin[0] = Origin[0] * d + x * (1 - d), Origin[1] = Origin[1] * d + y * (1 - d);
            Unit *= d;
            repreview(event);
        }

        function runCommand() {
            setTimeout(function () { Commanding = false; }, 100);
            
            var cmd = Command.innerText.toLocaleLowerCase();
            Command.innerText = "";
            Command.blur();

            if (cmd === "l" || cmd === "line") {
                CurrentEditing = Objs.length;
                Objs.push(new Array);
                Objs[CurrentEditing].push("segment");
                Status = "segment";
                if (FitPoint != -1) FitPoint = 1;
            }
        }

    </script>

    <script id="Shapes">
        function Line(ctx, obj) {
            var pointlist = Objs[obj];
            if (pointlist.length < 2) return;
            ctx.beginPath();
            var i = 0; if ("string" == typeof pointlist[0]) i = 1;
            var P = fromCoordinate(Points[pointlist[i]]);
            ctx.moveTo(P[0], P[1]);
            for (i++; i < pointlist.length; i++) {
                P = fromCoordinate(Points[pointlist[i]]);
                ctx.lineTo(P[0], P[1]);
            }
            if (obj == CurrentEditing && !isNaN(Points[0][0])) {
                P = fromCoordinate(Points[0]);
                ctx.lineTo(P[0], P[1]);
            }
            ctx.stroke();
        }

        function Segment(ctx, obj) {
            ctx.beginPath();
            var P = fromCoordinate(Points[Objs[obj][1]]);
            ctx.moveTo(P[0], P[1]);
            if (Objs[obj].length == 3) P = fromCoordinate(Points[Objs[obj][2]]);
            else if (!isNaN(Points[0][0])) P = fromCoordinate(Points[0]);
            ctx.lineTo(P[0], P[1]);
            ctx.stroke();
        }

    </script>
</body>
</html>
