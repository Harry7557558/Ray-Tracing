<!doctype html>
<html>
<head>
    <title>MyCAD 2D</title>
    <meta charset="utf-8" />
    <style>
        #content {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }

        #canvas, #preview {
            position: fixed;
            left: 0;
            top: 0;
            margin: 0;
            padding: 0;
            cursor: none;
        }

        #tool {
            position: fixed;
            right: 20px;
            top: 20px;
        }

        #cmd {
            position: fixed;
            bottom: 10px;
            height: 14px;
            padding: 2px 10px;
            border-radius: 3px;
            background-color: rgb(240,245,250);
            opacity: 0.8;
            line-height: 14px;
            font-family: Consolas;
            font-size: 12px;
            font-weight: 400;
            white-space: nowrap;
        }
    </style>
    <script id="global">
        var canvas, preview, Command;

        var Origin = [0, 0], Unit = 15;

        function fromCoordinate(P) {
            return [P[0] * Unit + Origin[0], -P[1] * Unit + Origin[1]];
        }
        function fromCanvas(P) {
            return [(P[0] - Origin[0]) / Unit, -(P[1] - Origin[1]) / Unit];
        }

        var Points = [[NaN, NaN], [0, 0]];
        var Objs = [];
        var Status = "select";
        var CursorType = "default";
        var CurrentEditing = -1;

        var PreviousWindowSize = [0, 0];
        function init() {
            canvas = document.getElementById("canvas"), preview = document.getElementById("preview");
            Command = document.getElementById("cmd");
            var w = window.innerWidth, h = window.innerHeight;
            PreviousWindowSize = [w, h];
            Origin = [w / 2, h / 2];
            Command.style.width = (0.6 * w) + "px", Command.style.left = (0.2 * w) + "px";
            Command.style.bottom = (0.0002 * h * h) + "px", Command.style.height = Command.style.lineHeight = (14 + 0.01 * h) + "px";
            Array.prototype.insert = function (item, index) {
                this.splice(index, 0, item);
            };
            Array.prototype.contains = function (obj) {
                var i = this.length;
                while (i--) {
                    if (this[i] === obj) return true;
                }
                return false;
            };
            window.onresize = function () {
                resizeCanvas();
            },
            window.onkeydown = function () {
                Onkeydown(event);
            },
            window.onkeyup = function () {
                Onkeyup(event);
            },
            window.onmousewheel = function () {
                mouseScroll(event);
            };
            resizeCanvas();
        }
        function resizeCanvas() {
            var w = Math.floor(window.innerWidth), h = Math.floor(window.innerHeight);
            var prevw = PreviousWindowSize[0], prevh = PreviousWindowSize[1];
            Unit *= Math.sqrt((w * h) / (prevw * prevh));
            Origin[0] *= w / prevw, Origin[1] *= h / prevh;
            PreviousWindowSize = [w, h];
            if ((canvas.width !== w) || (canvas.height !== h)) {
                canvas.width = preview.width = w;
                canvas.height = preview.height = h;
                canvas.style.width = preview.style.width = w + "px";
                canvas.style.height = preview.style.height = h + "px";
            }
            Command.style.width = (0.6 * w) + "px", Command.style.height = Command.style.lineHeight = (14 + 0.01 * h) + "px";
            Command.style.fontSize = (12 + 0.002 * h) + "px";
            redraw();
        }

        var FitPoint = 0;  // 0: disable(default); -1: disable(manual); 1: on
        var FitPointTarget = -1;

        var EditHistory = [[1]];
        function logHistory(opr) {
            if (EditHistory[0] < EditHistory.length) {
                EditHistory.splice(EditHistory[0], EditHistory.length - EditHistory[0]);
            }
            EditHistory.push(opr);
            EditHistory[0]++;
        }
        function restoreHistory() {

        }

        var Commanding = false;
    </script>
</head>
<body onload="init()">
    <div id="content" oncontextmenu="event.preventDefault()">
        <canvas id="canvas"></canvas>
        <canvas id="preview" onmousemove="cursorMove(event)" onclick="mouseClick(event)" oncontextmenu="rightClick(event)"></canvas>
        <div id="tool"></div>
        <div id="cmd" title="command line" contenteditable spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"
             onfocus="Commanding=true;"onkeydown="if (event.keyCode == 13) event.preventDefault(), runCommand();"></div>
    </div>
    <script>
        Objs.push(new Array);
        Objs[Objs.length - 1].push("segment");

        function Objs_erase(dir) {
            Objs.splice(dir, 1);
            if (CurrentEditing > dir) CurrentEditing--;
        }

        function redraw() {
            var w = canvas.width, h = canvas.height;
            var ctx = canvas.getContext("2d");

            // Background
            ctx.fillStyle = "rgb(16,20,23)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            var L = 100 / Unit;
            var tp = Math.pow(10, Math.floor(Math.log(L) / Math.LN10));
            L /= tp; L = (L < 2 ? 1 : L < 5 ? 2 : 5) * tp;
            var l = L / 5;
            var LeftTop = fromCanvas([0, 0]), RightBottom = fromCanvas([w, h]);
            LeftTop[0] = Math.round(LeftTop[0] / l - 0.5), LeftTop[1] = Math.round(LeftTop[1] / l + 0.5);
            RightBottom[0] = Math.round(RightBottom[0] / l + 0.5), RightBottom[1] = Math.round(RightBottom[1] / l - 0.5);

            // Minor gridlines
            ctx.strokeStyle = "rgb(55,65,75)";
            ctx.lineWidth = 0.2;
            ctx.setLineDash([]);
            ctx.beginPath();
            for (var i = LeftTop[0]; i <= RightBottom[0]; i++) {
                var P = fromCoordinate([i * l, 0]);
                ctx.moveTo(P[0], 0), ctx.lineTo(P[0], h);
            }
            for (var i = LeftTop[1]; i >= RightBottom[1]; i--) {
                var P = fromCoordinate([0, i * l]);
                ctx.moveTo(0, P[1]), ctx.lineTo(w, P[1]);
            }
            ctx.stroke();

            // Major gridlines
            LeftTop[0] = Math.round(LeftTop[0] / 5 - 0.5), LeftTop[1] = Math.round(LeftTop[1] / 5 + 0.5);
            RightBottom[0] = Math.round(RightBottom[0] / 5 + 0.5), RightBottom[1] = Math.round(RightBottom[1] / 5 - 0.5); ctx.strokeStyle = "rgb(55,65,75)";
            ctx.lineWidth = 0.4;
            ctx.beginPath();
            for (var i = LeftTop[0]; i <= RightBottom[0]; i++) {
                var P = fromCoordinate([i * L, 0]);
                ctx.moveTo(P[0], 0), ctx.lineTo(P[0], h);
            }
            for (var i = LeftTop[1]; i >= RightBottom[1]; i--) {
                var P = fromCoordinate([0, i * L]);
                ctx.moveTo(0, P[1]), ctx.lineTo(w, P[1]);
            }
            ctx.stroke();

            // Axis
            ctx.strokeStyle = "rgb(80,75,140)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(Origin[0], 0);
            ctx.lineTo(Origin[0], canvas.height);
            ctx.moveTo(0, Origin[1]);
            ctx.lineTo(canvas.width, Origin[1]);
            ctx.stroke();

            // Objects
            ctx.strokeStyle = "White";
            ctx.lineWidth = 1.2;
            for (var i = 0; i < Objs.length; i++) {
                if (Objs[i].length <= 1) Objs_erase(i), i--;
                else switch (Objs[i][0]) {
                    case "polyline": {
                        Line(ctx, i); break;
                    }
                    case "segment": {
                        Segment(ctx, i); break;
                    }
                }
            }

        }
        function repreview(mouseevent) {
            redraw();
            var ctx = preview.getContext("2d");
            ctx.clearRect(0, 0, preview.width, preview.height);
            drawCursor(mouseevent);
            if (FitPointTarget != -1) highlightPoint(Points[FitPointTarget]);
        }

        function drawCursor(event) {
            var x = event.clientX, y = event.clientY;
            var ctx = preview.getContext("2d");
            switch (CursorType) {
                case "default": {
                    ctx.strokeStyle = "Lime";
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(x - 12, y);
                    ctx.lineTo(x + 12, y);
                    ctx.moveTo(x, y - 12);
                    ctx.lineTo(x, y + 12);
                    ctx.stroke();
                    break;
                }
            }
        }
        function highlightPoint(P) {
            var ctx = preview.getContext("2d");
            ctx.strokeStyle = "Lime";
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            var Q = fromCoordinate(P);
            ctx.moveTo(Q[0] - 6, Q[1]);
            ctx.lineTo(Q[0] + 6, Q[1]);
            ctx.moveTo(Q[0], Q[1] - 6);
            ctx.lineTo(Q[0], Q[1] + 6);
            ctx.stroke();
        }



    </script>

    <script id="events">
        function FindFitPoint(P) {
            var dist = Infinity, dir = -1, dx, dy, d;
            for (var i = 1; i < Points.length; i++) {
                dx = P[0] - Points[i][0], dy = P[1] - Points[i][1];
                d = dx * dx + dy * dy;
                if (d < dist) dist = d, dir = i;
            }
            if (CurrentEditing != -1 && dir == Objs[CurrentEditing][Objs[CurrentEditing].length - 1]) return -1;
            if (Math.sqrt(dist) * Unit < 20) return dir;
            return -1;
        }

        function cursorMove(event) {
            var P = fromCanvas([event.clientX, event.clientY]);
            switch (Status) {
                case "select": {
                    repreview(event);
                    break;
                }
                case "segment": {
                    Points[0] = P;
                    if (FitPoint == 1) {
                        FitPointTarget = FindFitPoint(P);
                    }
                    repreview(event);
                    break;
                }
                case "circle": {
                    break;
                }
                case "arc": {
                    break;
                }
                case "spline": {
                    break;
                }
            }
        }

        function mouseClick(event) {
            Commanding = false;
            if (FitPoint != -1) FitPoint = 1;

            // For debug
            if (Status == "select") {
                Objs.push(new Array);
                CurrentEditing = Objs.length - 1;
                Objs[CurrentEditing].push("segment");
                Status = "segment";
            }

            var P = fromCanvas([event.clientX, event.clientY]);
            var ctx = canvas.getContext("2d");
            ctx.strokeStyle = "White";
            switch (Status) {
                case "select": {
                    break;
                }
                case "segment": {
                    if (FitPointTarget != -1) {
                        Objs[CurrentEditing].push(FitPointTarget);
                        FitPointTarget = -1;
                    }
                    else {
                        Points.push(P);
                        Objs[CurrentEditing].push(Points.length - 1);
                    }
                    if (Objs[CurrentEditing].length == 3) {
                        Objs.insert(["segment", Objs[CurrentEditing][1], Objs[CurrentEditing][2]], CurrentEditing);
                        logHistory(["new segment", CurrentEditing, Objs[CurrentEditing][1]]);
                        if (Objs[CurrentEditing][1] > Objs[CurrentEditing][2]) {
                            var c = Objs[CurrentEditing][1];
                            Objs[CurrentEditing][1] = Objs[CurrentEditing][2], Objs[CurrentEditing][2] = c;
                        }
                        CurrentEditing++;
                        Objs[CurrentEditing].splice(1, 1);
                    }
                    else {
                        logHistory(["begin line", Objs[CurrentEditing][1]]);
                    }
                    console.log(EditHistory);
                    break;
                }
                case "circle": {
                    break;
                }
                case "arc": {
                    break;
                }
                case "spline": {
                    break;
                }
            }
        }

        var keyStack = [];
        function Onkeydown(event) {
            if (Commanding) return;
            if (event.keyCode != 116 && event.keyCode != 123) event.preventDefault();   // F5, F12
            else return;
            if (keyStack[keyStack.length - 1] == event.keyCode) return;
            keyStack.push(event.keyCode);
            switch (event.keyCode) {
                case 13: { // Enter
                    Points[0] = [NaN, NaN];
                    Status = "select";
                    if (Objs[CurrentEditing].length <= 2) Objs_erase(CurrentEditing);
                    CurrentEditing = -1;
                    if (FitPoint != -1) FitPoint = 0;
                    FitPointTarget = -1;
                    cursorMove(event);
                    //redraw(); break;
                    mouseClick(event); return;   // For debug
                }
                case 16: { // Shift
                    console.log("Shift");
                    break;
                }
                case 17: { // Ctrl
                    console.log("Ctrl");
                    break;
                }
                case 18: { // Alt
                    console.log("Alt");
                    break;
                }
                case 20: { // Caps Lock

                }
                case 33: { // PageUp
                    Origin[1] -= canvas.height * 0.3;
                    redraw(); return;
                }
                case 34: { // PageDown
                    Origin[1] += canvas.height * 0.3;
                    redraw(); return;
                }
                case 37: { // left
                    Origin[0] -= canvas.width * 0.1;
                    redraw(); return;
                }
                case 38: { // top
                    Origin[1] -= canvas.height * 0.1;
                    redraw(); return;
                }
                case 39: { // right
                    Origin[0] += canvas.width * 0.1;
                    redraw(); return;
                }
                case 40: { // bottom
                    Origin[1] += canvas.height * 0.1;
                    redraw(); return;
                }
                case 89: { // y
                    if (keyStack.length == 2 && keyStack[0] == 17) {
                        console.log("Ctrl+Y");
                        return;
                    }
                    break;
                }
                case 90: { // z
                    if (keyStack.length == 2 && keyStack[0] == 17) { // Ctrl+Z
                        if (EditHistory[0] <= 2) {
                            EditHistory = [[1]];
                            if (Status == "segment") Objs_erase(CurrentEditing);
                            Status = "select";
                            CurrentEditing = -1;
                            redraw(); return;
                        }
                        console.log("Ctrl+Z");
                        EditHistory[0]--;
                        var _beginLine = function _beginLine(hist) {
                            if (Status == "segment") {
                                Objs[CurrentEditing][1] = hist[1];
                            }
                        };
                        var _newSegment = function _newSegment(hist) {
                            var del = hist[1];
                            hist[1] = Objs[del].slice(0);
                            if (Status == "segment") {
                                Objs[CurrentEditing][1] = hist[2];
                            }
                            Objs_erase(del);
                        };
                        var hist = EditHistory[EditHistory[0]];
                        switch (hist[0]) {
                            case "begin line": {
                                _beginLine(hist.slice(0, 2)); break;
                                // signature, dir of beginpoint
                            }
                            case "new segment": {
                                _newSegment(hist.slice(0, 3)); break;
                                // signature, dir of object, dir of beginpoint
                            }
                        }
                        redraw(); return;
                    }
                    break;
                }
                case 114: { // F3
                    if (FitPoint == -1) FitPoint = (CurrentEditing == -1) ? 0 : 1;
                    else FitPoint = -1, FitPointTarget = -1;
                    console.log("F3");
                    return;
                }
                case 122: { // F11
                    document.getElementById("content").webkitRequestFullscreen();
                    return;
                }
                default: {
                    console.log("Keycode: ", event.keyCode);
                    break;
                }
            }
            if (event.keyCode >= 65 && event.keyCode <= 90) {
                Commanding = true;
                KeyStack = [];
                Command.innerText += String.fromCharCode(event.keyCode + 32);

                // Based on https://stackoverflow.com/questions/1125292/how-to-move-cursor-to-end-of-contenteditable-entity
                var setEndOfContenteditable = function (contentEditableElement) {
                    var voidNodeTags = ['AREA', 'BASE', 'BR', 'COL', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'MENUITEM', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR', 'BASEFONT', 'BGSOUND', 'FRAME', 'ISINDEX'];
                    var canContainText = function canContainText(node) {
                        if (node.nodeType == 1) return !voidNodeTags.contains(node.nodeName);
                        else return false;
                    };
                    var getLastChildElement = function getLastChildElement(el) {
                        var lc = el.lastChild;
                        while (lc && lc.nodeType != 1) {
                            if (lc.previousSibling) lc = lc.previousSibling;
                            else break;
                        }
                        return lc;
                    };
                    while (getLastChildElement(contentEditableElement) &&
                          canContainText(getLastChildElement(contentEditableElement))) {
                        contentEditableElement = getLastChildElement(contentEditableElement);
                    }
                    var range, selection;
                    if (document.createRange)//Firefox, Chrome, Opera, Safari, IE 9+
                    {
                        range = document.createRange();//Create a range (a range is a like the selection but invisible)
                        range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range
                        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
                        selection = window.getSelection();//get the selection object (allows you to change selection)
                        selection.removeAllRanges();//remove any selections already made
                        selection.addRange(range);//make the range you have just created the visible selection
                    }
                    else if (document.selection)//IE 8 and lower
                    {
                        range = document.body.createTextRange();//Create a range (a range is a like the selection but invisible)
                        range.moveToElementText(contentEditableElement);//Select the entire contents of the element with the range
                        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
                        range.select();//Select the range (make it the visible selection
                    }
                }

                Command.focus();
                setEndOfContenteditable(Command);
            }
        }
        function Onkeyup(event) {
            if (Commanding) return;
            if (event.keyCode != 116 && event.keyCode != 123) event.preventDefault();
            else return;
            for (i = keyStack.length - 1; i >= 0; i--) {
                if (keyStack[i] == event.keyCode) {
                    keyStack.splice(i, 1);
                    //break;
                }
            }
        }

        function rightClick(event) {

        }

        function mouseScroll(event) {
            var d = Math.exp(0.0008 * event.wheelDelta);
            var x = event.clientX, y = event.clientY;
            Origin[0] = Origin[0] * d + x * (1 - d), Origin[1] = Origin[1] * d + y * (1 - d);
            Unit *= d;
            repreview(event);
        }

        function runCommand() {
            setTimeout(function () { Commanding = false; }, 100);
            
            var cmd = Command.innerText;
            Command.innerText = "";
            Command.blur();
        }

    </script>

    <script id="Shapes">
        function Line(ctx, obj) {
            var pointlist = Objs[obj];
            if (pointlist.length < 2) return;
            ctx.beginPath();
            var i = 0; if ("string" == typeof pointlist[0]) i = 1;
            var P = fromCoordinate(Points[pointlist[i]]);
            ctx.moveTo(P[0], P[1]);
            for (i++; i < pointlist.length; i++) {
                P = fromCoordinate(Points[pointlist[i]]);
                ctx.lineTo(P[0], P[1]);
            }
            if (obj == CurrentEditing && !isNaN(Points[0][0])) {
                P = fromCoordinate(Points[0]);
                ctx.lineTo(P[0], P[1]);
            }
            ctx.stroke();
        }

        function Segment(ctx, obj) {
            ctx.beginPath();
            var P = fromCoordinate(Points[Objs[obj][1]]);
            ctx.moveTo(P[0], P[1]);
            if (Objs[obj].length == 3) P = fromCoordinate(Points[Objs[obj][2]]);
            else if (!isNaN(Points[0][0])) P = fromCoordinate(Points[0]);
            ctx.lineTo(P[0], P[1]);
            ctx.stroke();
        }

    </script>
</body>
</html>
